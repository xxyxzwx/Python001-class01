学习笔记
1. 连续赋值是让位于前面的对象的值等于最后一个对象的值
2. 用一个变量给另一个变量赋值，其实就是给当前内存中的对象增加一个“标签”而已，这两个变量指向的是同一片内存。
所以调用对象的方法对该对象进行修改(list.append/list[0]=xxx)两个变量依然指向同一个内存地址，即两个变量的值相同。
而对一个变量重新进行赋值(list1=[4,5,6])，这个变量指向的内存地址发生变化，两个变量不在指向同一片内存地址，即两个变量的值不同。
3. 浅拷贝是copy一个对象指向源对象的内存地址，类似于软链接
   深拷贝是将对象完全copy同时新申请一个内存地址进行存放，生成一个新的对象
4. 在获取可变长度参数时，**kwargs会优先获取关键字参数，再把剩余参数传递给*args；
   同时存在传递顺序问题，KV类型的参数必须在最后，否则报错
5. 闭包的特性：
1) 外部函数和内部函数不太相关：外部函数主要作为定义某些功能的初次定义，内部函数让程序运行得到结果；
2) 定义时设置好规则，而非运行时设置
6. 将class制作成装饰器需要添加__call__方法（将实例对象变成可调用对象），作为装饰器使用时，就会执行__call__定义的代码
7. 鸭子类型：python不关注变量是何种数据类型，只关注变量有何种方法，如果有字典的方法就当成字典类型使用
与鸭子类型相反的是静态类型，声明变量的时候指定类型，如果使用其他类型对变量赋值就会报错
python不使用静态类型，运行时动态的判断变量的方法，所以添加类型注解，只能做注解用，并不能强制指定类型
#->表明返回的会是什么类型
8. future是一种特殊的 低层级 可等待对象，表示一个异步操作的 最终结果。
当一个 Future 对象 被等待，这意味着协程将保持等待直到该 Future 对象在其他地方操作完毕。
在 asyncio 中需要 Future 对象以便允许通过 async/await 使用基于回调的代码。
通常情况下 没有必要 在应用层级的代码中创建 Future 对象。